---
title: "blogpost2"
output:
  html_document:
    toc: true
    toc_depth: 2
---

This is a second post in a series of dplyr functions.
The first one can be found here (link), and covered teh following elements
- content

this second one covers
- content

**The data**
As in the previous blog posts a lot of these functions truly when you have a lot of columns, but to make it easy on people to copy paste code and experiment, I'm using a built-in dataset:
```{r message=FALSE, warning=FALSE}
library(tidyverse)

glimpse(msleep)
```
<br><br>

# Getting the columns you need:

## **Transforming data into a new column**

You can make new columns with the `mutate` function. The options inside mutate are almost endless: pretty much anything that you can do to normal vectors, can be done inside a mutate function.  
Anything inside a mutate can either be a new column (by giving mutate a new column name), or can replace the current column (by keeping the same column name)
  
One of the many options is a calculation based on values in other columns:

```{r}
#new column for sleep time in minutes
msleep %>%
  select(name, sleep_total) %>%
  mutate(sleep_total_min = sleep_total * 60)
```
<br>

The new column can be made with functions such as average, median, max, min, ...   

```{r}
msleep %>%
  select(name, sleep_total) %>%
  mutate(sleep_total_vs_AVG = sleep_total - round(mean(sleep_total),1),
         sleep_total_vs_MIN = sleep_total - min(sleep_total))
```
<br>

The `ifelse` statement is particularly useful if you don't want to mutate the whole column in the same way. You first specify a logical statement, afterwards what needs to happen if the statement returns `TRUE`, and lastly what needs to happen if it's  `FALSE`.  
  
Imagine that we have a database with two large values which we assume are typo's or measurement errors:

```{r}
msleep %>%
  mutate(brainwt2 = ifelse(brainwt > 4, NA, brainwt)) %>%
  select(starts_with("brain")) %>%
  arrange(desc(brainwt))
```
<br> 

You can also mutate string columns with stringr's `str_extract()` function in combation with any character or regex patterns.

```{r}
#adding new column which has only the first word of the project name
msleep %>%
  mutate(name_last_word = tolower(str_extract(name, pattern = "\\w+$"))) %>%
  select(name, name_last_word)
```

<br><br>




## **Workin with discrete columns**

### **Recoding discrete columns**

To rename or reorganize current discrete columns, you can use `recode()` inside a `mutate()` statement:


```{r}
msleep %>%
  mutate(conservation2 = recode(conservation,
                        "en" = "Endangered",
                        "lc" = "Least_Concern",
                        .default = "other")) %>%
  count(conservation2)
  
```
<br>


### **Creating new discrete column (two levels)**

The `if_else()` statement is useful when you want to turn a numeric column into a discrete one. 

```{r}
msleep %>%
  mutate(sleep_time = ifelse(sleep_total > 10, "long", "short")) %>%
  glimpse
  
```
<br>

### **Creating new discrete column (multiple levels)**

The `ifelse()` can be nested but if you want more than two levels, it might be even easier to use `case_when()` which allows as many statements as you like.  
The arguments are evaluated in order, so only the rows where the first statement is not true will continue to be evaluated for the next statement. For everything that is left at the end just use the `TRUE ~ "newname"`.

```{r}
msleep %>%
  mutate(sleep_total_disc = case_when(
    sleep_total > 13 ~"very long",
    sleep_total > 10 ~ "long",
    sleep_total > 7 ~"limited",
    TRUE ~ "short")) %>%
  mutate(sleep_total_disc = forcats::fct_relevel(sleep_total_disc, 
                                                 "short", "limited", "long", "very long")) %>%
  count(sleep_total_disc)
```
<br>

The `case_when()` function does not only work inside a column, but can be used for grouping across columns:

```{r}
msleep %>%
  mutate(silly_groups = case_when(
    brainwt < 0.001 ~ "light_headed",
    sleep_total > 10 ~ "lazy_sleeper",
    is.na(sleep_rem) ~ "absent_rem",
    TRUE ~ "other")) %>%
  count(silly_groups)
```
<br><br>




## **Merging and unmerging columns**

Take for example this dataset
```{r}
(conservation_expl <- read_csv("conservation_explanation.csv"))
```


You can unmerge any columns by using tidyr's `separate())` function. To do this, you have to specify the column to be splitted, followed by the new column names, and which seperator it has to look for. 

```{r}
(conservation_table <- conservation_expl %>%
  separate(`conservation abbreviation`, 
           into = c("abbreviation", "description"), sep="=") %>%
  mutate_all(str_trim))
  #alternative: mutate_all(~str_replace_all(., " ", "")))
```
<br>

The opposite is tidyr's `unite()` function. You specify the new column name, and then the columns to be united, and lastly what seperator you want to use. 



```{r}
#merging currency and goal columns
conservation_table %>%
  unite(united_col, abbreviation, description, sep=": ") %>%
  select(united_col)
```

<br><br>

## **Adding columns from other tables**

If you want to add information from another type, you can use the joining functions from dplyr. The msleep data contains abbreviations for conservation but if you are not familiar with the topic you might need the description we used in the section above inside the msleep data.  


```{r}
#joining column data
msleep %>%
  select(name, conservation) %>%
  mutate(conservation = toupper(conservation)) %>%
  left_join(conservation_table, by = c("conservation" = "abbreviation")) %>%
  mutate(description = ifelse(is.na(description), conservation, description))
```





## **Mutating several columns at once**


```{r}
msleep %>%
  mutate_all(tolower)
```

```{r}
msleep %>%
  mutate_all(~str_replace_all(., "[aeiou]", ""))
```


mutate_if
```{r}
msleep %>%
  mutate_if(is.numeric, round) %>%
  select(sleep_total:bodywt)
```


## mutating specific columns


All columns containing the word sleep are in hours, but if I want those in minutes, I can use `mutate_at()`. To indicate that I want the condition to be based on the column name I can use `vars(contains("sleep"))`.  
The second argument of `mutate_at()` needs to be function, so I have to wrap my calculation instructions with a tilde to make a function on the fly.
```{r}
msleep %>%
  mutate_at(vars(contains("sleep")), ~(.*60)) %>%
  select(sleep_total:bodywt)
```

